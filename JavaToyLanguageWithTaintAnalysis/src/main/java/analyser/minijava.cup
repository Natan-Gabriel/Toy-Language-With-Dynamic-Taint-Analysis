package analyser;
import model.stmt.*;
import model.exp.*;
import model.types.*;
import model.values.*;
import java.util.*;
import java.io.*;
import java_cup.runtime.Symbol;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.ComplexSymbolFactory;
import java_cup.runtime.ScannerBuffer;
import javafx.util.Pair;
parser code {:
  static int count=0;
  static  Map<Integer, IStmt> map = new HashMap<Integer, IStmt>();
  static List<IStmt> list= new ArrayList<IStmt>();

  public boolean syntaxErrors;


  Lexer lexer;

  public Parser(Lexer lex, ComplexSymbolFactory sf) {
    super(lex,sf);
    lexer = lex;
  }

  public static void main(String[] args) throws Exception {
        // initialize the symbol factory
        ComplexSymbolFactory csf = new ComplexSymbolFactory();
        // create a buffering scanner wrapper
        ScannerBuffer lexer = new ScannerBuffer(new Lexer(new BufferedReader(new FileReader(args[0])),csf));
        // start parsing
        Parser p = new Parser(lexer,csf);

        //XMLElement e = (XMLElement)p.parse().value;
        System.out.println("aici");
        System.out.println(p.parse().value);

        /*for (XMLElement el: SyntaxTreeXPath.query(args[2],e)){
        	  System.out.println(el.getTagname());
        }


        TestVisitor t = new TestVisitor();
        SyntaxTreeDFS.dfs(e,t);

        // create XML output file
        XMLOutputFactory outFactory = XMLOutputFactory.newInstance();
        XMLStreamWriter sw = outFactory.createXMLStreamWriter(new FileOutputStream(args[1]),"UTF-8");
        // dump XML output to the file
        XMLElement.dump(lexer,sw,e,"expr","stmt");

         // transform the parse tree into an AST and a rendered HTML version
        Transformer transformer = TransformerFactory.newInstance()
  	    .newTransformer(new StreamSource(new File("tree.xsl")));
        Source text = new StreamSource(new File(args[1]));
        transformer.transform(text, new StreamResult(new File("output.xml")));
        transformer = TransformerFactory.newInstance()
  	    .newTransformer(new StreamSource(new File("tree-view.xsl")));
        text = new StreamSource(new File("output.xml"));
        transformer.transform(text, new StreamResult(new File("ast.html"))); */
    }

    /*public static void constructMap(){
        int aux = count;
        while (aux>=1){
            if(list.get(aux-1) instanceof IfStmt){
                IfStmt stmt = (IfStmt)list.get(aux-1);
                map.put(aux - stmt.getTotalLength(),stmt);
                System.out.println("stmt.getTotalLength():"+stmt.getTotalLength());
                for(int i=1;i<=stmt.getTotalLength();i++){
                    map.put(aux - stmt.getTotalLength()+i,list.get(aux-stmt.getTotalLength()+i-2));
                }
                aux-=stmt.getTotalLength();
                aux--;
            }
            else{
                map.put(aux,list.get(aux-1));
                aux--;
            }

        }
    }*/
    public static void constructMap(){
        int count = list.size();
        int depth = 0;
        Stack<Integer> nestedStatementsStack = new Stack<>();

        System.out.println("LIST before"+list);
        Collections.reverse(list);
        System.out.println("LIST after"+list);

        for(IStmt stmt : list) {
            int statementNumber = count - stmt.getNumberOfNestedStatements() + depth;
            System.out.println(stmt+" has count "+count+" number of nested statements "+stmt.getNumberOfNestedStatements() +" and depth "+depth+". So statement number is "+statementNumber);
            stmt.setStatementNumber(statementNumber);
            map.put(statementNumber,stmt);
            count--;
            System.out.println(stmt+" is at position "+statementNumber);
            //System.out.println("verif "+new Integer(statementNumber).equals(nestedStatementsStack.peek())+" "+new Integer(statementNumber)+" "+nestedStatementsStack.peek());
            while (!nestedStatementsStack.empty() && nestedStatementsStack.peek().equals(statementNumber)){
                depth--;
                nestedStatementsStack.pop();
            }

            if ((stmt instanceof IfStmt) ||  (stmt instanceof WhileStmt)){
                depth++;
                nestedStatementsStack.push(statementNumber+1);
            }
        }


    }

    public synchronized static Object parse(String arg) throws Exception {
            // initialize the symbol factory
            ComplexSymbolFactory csf = new ComplexSymbolFactory();
            // create a buffering scanner wrapper
            ScannerBuffer lexer = new ScannerBuffer(new Lexer(new BufferedReader(new FileReader(arg)),csf));
            // start parsing
            Parser p = new Parser(lexer,csf);

            //XMLElement e = (XMLElement)p.parse().value;
            System.out.println("aici");
            map = new HashMap<Integer, IStmt>();
            list= new ArrayList<IStmt>();
            Object res=p.parse().value;
            System.out.println("res:"+res+"res_printed");
            constructMap();
            System.out.println("list:"+list+"list_printed");
            System.out.println("map:"+map+"map_printed");
            System.out.println("count:"+count+"count_printed");

            return map;

        }
        /*logicexpr1::= BOOLCONST:c
            {: RESULT = new ValueExp(new BoolValue(c));  : }
            |  IDENT:i
            {: RESULT = new VarExp(i); : }
            | LPAR logicexpr:e RPAR
            {: RESULT = e; : }
            | expr:e1 COMP:op expr:e2
            {: //| expr:e1 COMP:op expr:e2 RESULT = new RelationalExp(op,e1,e2);
             : }
            ;*/


:};

terminal         SEMICOLON, COMMA, LPAR, RPAR, BEGIN, END,IF, ELSE, WHILE, FOR, READ_INTEGER, READ_HEAP, OPEN_FILE, READ_FILE, CLOSE_FILE, WRITE, PRINT, BUNOP, ASSIGN, GOTO;
terminal Integer UNOP, INTCONST;
terminal String  IDENT,STRINGCONST, COMP, BBINOP;
terminal char BINOPPRIORITY1, BINOPPRIORITY2;
terminal Boolean BOOLCONST;
terminal Type TYPE;


non terminal String program;
non terminal String decllist;
non terminal Pair<String,Exp> assignment;
non terminal List<Pair<String,Exp>> identlist;
non terminal Exp expr,logicexpr,relexp,logicexpr1,stringexp;
non terminal List<IStmt> stmt;
non terminal List<IStmt> decl;
non terminal List<IStmt> stmtlist;

precedence left COMP;
precedence left BINOPPRIORITY2;
precedence left BINOPPRIORITY1;
precedence left ELSE, UNOP, BUNOP, BBINOP;


program   ::=  stmtlist:s
    {: System.out.println("before"+map+"after");
     RESULT = s.toString(); :}
    ;
decllist  ::= decl:d decllist:dl
    {:
    dl+=d; RESULT = dl;
    :}
    | /* empty decllist */
    {: RESULT = ""; :}
    ;

decl ::= TYPE:type assignment:i identlist:il SEMICOLON
    {:
    IStmt decl_stmt,assign_stmt ;
    List<IStmt> res = new ArrayList<IStmt>();
    decl_stmt = new VarDeclStmt(i.getKey(),type,count,typexleft.getLine());
    res.add(decl_stmt);
    list.add(decl_stmt);
    count++;

    if(i.getValue()!=null){
        assign_stmt = new AssignStmt(i.getKey(),(Exp)i.getValue(),count,typexleft.getLine());
        res.add(assign_stmt);
        list.add(assign_stmt);
        count++;
    }

    for(Pair<String,Exp> elem : il){
        decl_stmt = new VarDeclStmt(elem.getKey(),type,count,typexleft.getLine());
        res.add(decl_stmt);
        list.add(decl_stmt);
        count++;
        if(elem.getValue()!=null){
            assign_stmt = new AssignStmt(elem.getKey(),(Exp)elem.getValue(),count,typexleft.getLine());
            res.add(assign_stmt);
            list.add(assign_stmt);
            count++;
        }
    }


    RESULT = res; :}
    ;
assignment ::= IDENT:i ASSIGN expr:e
     {:
     RESULT = new Pair<String,Exp>(i,e);
     :}
     | IDENT:i
     {:
        RESULT = new Pair<String,Exp>(i,null);
     :}
    ;
identlist  ::= identlist:il COMMA assignment:i
    {: il.add(i); RESULT = il; :}
     | /* empty identlist*/
     {: RESULT = new ArrayList<Pair<String,Exp>>(); :}
    ;

stmtlist  ::= stmtlist:sl stmt:s
    {: sl.addAll(s); RESULT = sl; :}
    | /* empty stmtlist */
    {: RESULT = new ArrayList<IStmt>(); :}
    ;

stmt ::= SEMICOLON:s
    {:
          IStmt stmt = new NopStmt(sxleft.getLine());
          list.add(stmt);
          count++;
          RESULT = Arrays.asList(stmt);
    :}
    | decl:d
    {:
        RESULT = d;
    :}
    | IDENT:i ASSIGN expr:e SEMICOLON
    {:
           IStmt stmt = new AssignStmt(i,(Exp)e,count,ixleft.getLine());
           list.add(stmt);
           count++;
           RESULT = new ArrayList<IStmt>(Arrays.asList(stmt));
     :}

    | IF:s LPAR expr:e RPAR BEGIN stmtlist:sl1 END:end
        {:

          IStmt stmt = new IfStmt((Exp)e,sl1,new ArrayList<IStmt>(),sxleft.getLine(),endxright.getLine());
          list.add(stmt);
          count++;
          RESULT = Arrays.asList(stmt);
         :}
    | IF:s LPAR expr:e RPAR BEGIN stmtlist:sl1 END ELSE BEGIN stmtlist:sl2 END:end
    {:

           IStmt stmt = new IfStmt((Exp)e,sl1,sl2,sxleft.getLine(),endxright.getLine());
           list.add(stmt);
           count++;
           RESULT = Arrays.asList(stmt);
     :}
    | WHILE:s LPAR expr:e RPAR BEGIN stmtlist:sl END:end
    {:
        /*System.out.println("exleft.getLine()"+exleft.getLine());
        System.out.println("exright.getLine()"+exright.getLine());
        System.out.println("slxleft.getLine()"+slxleft.getLine());
        System.out.println("slxright.getLine()"+slxright.getLine());*/
        IStmt stmt = new WhileStmt(e,sl,sxleft.getLine(),endxright.getLine());
        list.add(stmt);
        count++;
        RESULT = Arrays.asList(stmt);
    :}
    | FOR:s LPAR stmt:s1 expr:e SEMICOLON stmt:s3 RPAR BEGIN stmtlist:sl END:end
    {:
            // we will statement_s3 at the end
            //System.out.println("list is "+list);

            int numberOfNestedStatements = 0;
            for(IStmt istmt:sl){
                numberOfNestedStatements = numberOfNestedStatements + istmt.getNumberOfNestedStatements() + 1 ;
            }
            //System.out.println("sl is "+sl);
            //System.out.println("numberOfNestedStatements is "+numberOfNestedStatements);

            IStmt statement_s3 = list.remove(list.size() - 1 - numberOfNestedStatements);
            //System.out.println("statement_s3 is "+statement_s3);

            List<IStmt> res = new ArrayList<IStmt>();
            sl.addAll(s3);

            res.addAll(s1);
            IStmt while_stmt = new WhileStmt((Exp)e,sl,sxleft.getLine(),endxright.getLine());
            res.add( while_stmt );

            list.addAll(s3);
            list.add(while_stmt);

            count++;
            //System.out.println("res in FOR is "+res);
            RESULT = res;



            //RESULT = new CompStmt(s1,new WhileStmt((Exp)e,new CompStmt(sl,s3),sxleft.getLine(),endxright.getLine()));
    :}
    | GOTO:s expr:e SEMICOLON
      {:
           IStmt stmt = new GotoStmt((Exp)e,sxleft.getLine());
           list.add(stmt);
           count++;
           RESULT = Arrays.asList(stmt);
      :}
    | PRINT:s LPAR expr:e RPAR SEMICOLON
    {:
       IStmt stmt = new PrintStmt((Exp)e,sxleft.getLine());
       list.add(stmt);
       count++;
       RESULT = Arrays.asList(stmt);
    :}
    | error:e
    {: parser.report_error("Syntax error, skipped nonsense",e); :}
    ;


logicexpr ::= BOOLCONST:c
    {: System.out.println("BOOLCONST");
       RESULT = new ValueExp(new BoolValue(c));  :}
    | expr:e1 COMP:op expr:e2
    {: System.out.println("COMP"); RESULT = new RelationalExp(op,e1,e2); //RelationalExp
     :}

    ;
stringexp ::= STRINGCONST:sc
    {: System.out.println("STRINGCONST");
      RESULT = new ValueExp(new StringValue(sc));  :}
    ;

expr ::= INTCONST:c
    {: //System.out.println("new ValueExp(new IntValue("+c+")");
      //RESULT = "new ValueExp(new IntValue("+c+"))";
     RESULT = new ValueExp(new IntValue(c));  :}

    | IDENT: i
    {: RESULT = new VarExp(i); :}
    | LPAR expr:e RPAR
    {: RESULT = e;
     :}

    | expr:e1 BINOPPRIORITY1:op expr:e2
    {:  System.out.println("BINOP:op"+op);
    RESULT = new ArithExp(op,e1, e2);
    :}
    | expr:e1 BINOPPRIORITY2:op expr:e2
    {:  System.out.println("new ArithExp("+op+","+e1+","+ e2+")");
    RESULT = new ArithExp(op,e1, e2);
    :}
    | BINOPPRIORITY2:op expr:e
    {:  System.out.println("BINOP:op"+op);
    if(op=='+')
        RESULT = e;
    else if(op=='-')
        RESULT = new ArithExp('*',e, new ValueExp(new IntValue(-1)));
    :}
    | expr:e1 BBINOP:op expr:e2
     {: RESULT = new LogicExp(op,e1,e2); //LogicExp
      :}
    | logicexpr : l
     {:System.out.println("BOOLCONST");
       RESULT = l;
     :}
     | READ_INTEGER
     {:
      RESULT = new readInteger();
     :}
     | READ_HEAP LPAR expr:e RPAR
     {:
      RESULT = new rH(e);
     :}
     | stringexp:s
     {: //System.out.println("stringexp");
        RESULT = s;
     :}

    ;