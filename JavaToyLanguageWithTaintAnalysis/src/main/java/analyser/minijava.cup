package analyser;
import model.stmt.*;
import model.exp.*;
import model.types.*;
import model.values.*;
import java.util.*;
import java.io.*;
import java_cup.runtime.Symbol;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.ComplexSymbolFactory;
import java_cup.runtime.ScannerBuffer;
import javafx.util.Pair;
parser code {:
    int count=1;
    static Map<Integer, IStmt> map = new HashMap<Integer, IStmt>();
  public boolean syntaxErrors;


  Lexer lexer;

  public Parser(Lexer lex, ComplexSymbolFactory sf) {
    super(lex,sf);
    lexer = lex;
  }

  public static void main(String[] args) throws Exception {
        // initialize the symbol factory
        ComplexSymbolFactory csf = new ComplexSymbolFactory();
        // create a buffering scanner wrapper
        ScannerBuffer lexer = new ScannerBuffer(new Lexer(new BufferedReader(new FileReader(args[0])),csf));
        // start parsing
        Parser p = new Parser(lexer,csf);

        //XMLElement e = (XMLElement)p.parse().value;
        System.out.println("aici");
        System.out.println(p.parse().value);

        /*for (XMLElement el: SyntaxTreeXPath.query(args[2],e)){
        	  System.out.println(el.getTagname());
        }


        TestVisitor t = new TestVisitor();
        SyntaxTreeDFS.dfs(e,t);

        // create XML output file
        XMLOutputFactory outFactory = XMLOutputFactory.newInstance();
        XMLStreamWriter sw = outFactory.createXMLStreamWriter(new FileOutputStream(args[1]),"UTF-8");
        // dump XML output to the file
        XMLElement.dump(lexer,sw,e,"expr","stmt");

         // transform the parse tree into an AST and a rendered HTML version
        Transformer transformer = TransformerFactory.newInstance()
  	    .newTransformer(new StreamSource(new File("tree.xsl")));
        Source text = new StreamSource(new File(args[1]));
        transformer.transform(text, new StreamResult(new File("output.xml")));
        transformer = TransformerFactory.newInstance()
  	    .newTransformer(new StreamSource(new File("tree-view.xsl")));
        text = new StreamSource(new File("output.xml"));
        transformer.transform(text, new StreamResult(new File("ast.html"))); */
    }

    public static Object parse(String arg) throws Exception {
            // initialize the symbol factory
            ComplexSymbolFactory csf = new ComplexSymbolFactory();
            // create a buffering scanner wrapper
            ScannerBuffer lexer = new ScannerBuffer(new Lexer(new BufferedReader(new FileReader(arg)),csf));
            // start parsing
            Parser p = new Parser(lexer,csf);

            //XMLElement e = (XMLElement)p.parse().value;
            System.out.println("aici");
            Object res=p.parse().value;
            System.out.println("res:"+res+"res_printed");
            return map;

        }
        /*logicexpr1::= BOOLCONST:c
            {: RESULT = new ValueExp(new BoolValue(c));  : }
            |  IDENT:i
            {: RESULT = new VarExp(i); : }
            | LPAR logicexpr:e RPAR
            {: RESULT = e; : }
            | expr:e1 COMP:op expr:e2
            {: //| expr:e1 COMP:op expr:e2 RESULT = new RelationalExp(op,e1,e2);
             : }
            ;*/


:};

terminal         SEMICOLON, COMMA, LPAR, RPAR, BEGIN, END,IF, ELSE, WHILE, FOR, READ_INTEGER, READ_HEAP, OPEN_FILE, READ_FILE, CLOSE_FILE, WRITE, PRINT, BUNOP, ASSIGN, GOTO;
terminal Integer TYPE, UNOP, INTCONST;
terminal String  IDENT,STRINGCONST, COMP, BBINOP;
terminal char BINOPPRIORITY1, BINOPPRIORITY2;
terminal Boolean BOOLCONST;


non terminal String program;
non terminal String decllist;
non terminal String decl;
non terminal List<String> identlist;
non terminal Exp expr,logicexpr,relexp,logicexpr1,stringexp;
non terminal Pair<List<IStmt>, List<IStmt>> stmt;
non terminal Pair<List<IStmt>, List<IStmt>> stmtlist;

precedence left COMP;
precedence left BINOPPRIORITY2;
precedence left BINOPPRIORITY1;
precedence left ELSE, UNOP, BUNOP, BBINOP;


program   ::=  decllist:d stmtlist:s
    {: System.out.println("before"+map+"after");
     RESULT = d+s; :}
    ;
decllist  ::=  decl:d decllist:dl
    {:
    dl+=d; RESULT = dl;
    :}
    | /* empty decllist */
    {: RESULT = ""; :}
    ;

decl ::= TYPE IDENT:i identlist:il  SEMICOLON
    {: System.out.println(i) ;
    map.put(count,new VarDeclStmt(i,new IntType(),count,ixleft.getLine()));
    String res="";
    res+="{"+count+",new VarDeclStmt(\""+i+"\",new IntType(),"+count+","+ixleft.getLine()+")},";
    count++;
    for(String elem : il){
        map.put(count,new VarDeclStmt(elem,new IntType(),count,ixleft.getLine()));
        res+="{"+count+",new VarDeclStmt(\""+elem+"\",new IntType(),"+count+","+ixleft.getLine()+")},";
        count++;
    }

    RESULT = res; :}
    ;
identlist  ::= identlist:il COMMA IDENT:i
    {: il.add(i); RESULT = il; :}
     | /* empty identlist*/
     {: RESULT = new ArrayList<String>(); :}
    ;

stmtlist  ::= stmtlist:sl stmt:s
    {: sl.getKey().addAll(s.getKey()); sl.getValue().addAll(s.getValue()); RESULT = sl; :}
    | /* empty stmtlist */
    {: RESULT = new Pair<List<IStmt>,List<IStmt>>(new ArrayList<IStmt>(),new ArrayList<IStmt>()); :}
    ;

stmt ::= SEMICOLON
    {: :}
    | IDENT:i ASSIGN expr:e SEMICOLON
    {: //System.out.println("new AssignStmt(\""+i+"\","+ e +","+count+","+ixleft.getLine()+")},";
     map.put(count,new AssignStmt(i,(Exp)e,count,ixleft.getLine()));

     IStmt stmt = new AssignStmt(i,(Exp)e,count,ixleft.getLine());
     Pair<List<IStmt>, List<IStmt>> res = new Pair<>(new ArrayList<IStmt>(Arrays.asList(stmt)),
                                            new ArrayList<IStmt>(Arrays.asList(stmt)));
     System.out.println("new AssignStmt(\""+i+"\","+ e +","+count+","+ixleft.getLine()+")},");
     RESULT = res;
     count++;
     :}

    | IF LPAR expr:e RPAR BEGIN stmtlist:sl1 END
        {:
           //System.out.println("sl1.getValue():"+sl1.getValue());
           for(IStmt stmt : sl1.getValue()){

               int newStatementNumber=stmt.getStatementNumber()+1;
               System.out.println("stmt.getStatementNumber():"+stmt.getStatementNumber());
               stmt.setStatementNumber(newStatementNumber);
               System.out.println("stmt.getStatementNumber():"+stmt.getStatementNumber());
               map.put(newStatementNumber,stmt);
               System.out.println(stmt+"with number"+newStatementNumber);

           }

          System.out.println("sl1"+sl1);
          //System.out.println("sl2"+sl2);

          List<IStmt> direct_children = new ArrayList<IStmt>();
          List<IStmt> all_children = new ArrayList<IStmt>();

          //Pair<List<IStmt>, List<IStmt>> pair = new Pair<>(1, "One");

          System.out.println("This is sl1.getKey():"+sl1.getKey());
          List<IStmt> empty_list = new ArrayList<IStmt>();
          IfStmt if_stmt = new IfStmt((Exp)e,sl1.getKey(),empty_list,count-sl1.getValue().size(),sl1.getValue().size());
          //if_stmt.setNextInstruction(count+1);
          System.out.println("if_stmt.setNextInstruction is: "+(count+1));
          direct_children.add(if_stmt);
          all_children.add(if_stmt);
          all_children.addAll(sl1.getValue());


            System.out.println("count in if"+count);

           Pair<List<IStmt>, List<IStmt>> res = new Pair<>(direct_children, all_children);

           System.out.println("Pair<List<IStmt>, List<IStmt>> res = "+res);
           RESULT = res;
           map.put(count-sl1.getValue().size(),if_stmt);
           count++;
         :}
    | IF LPAR expr:e RPAR BEGIN stmtlist:sl1 END ELSE BEGIN stmtlist:sl2 END
    {:
       //System.out.println("sl1.getValue():"+sl1.getValue());
       for(IStmt stmt : sl1.getValue()){

           int newStatementNumber=stmt.getStatementNumber()+1;
           System.out.println("stmt.getStatementNumber():"+stmt.getStatementNumber());
           stmt.setStatementNumber(newStatementNumber);
           System.out.println("stmt.getStatementNumber():"+stmt.getStatementNumber());
           map.put(newStatementNumber,stmt);
           System.out.println(stmt+"with number"+newStatementNumber);

       }
       for(IStmt stmt : sl2.getValue()){

          int newStatementNumber=stmt.getStatementNumber()+1;
          System.out.println("stmt.getStatementNumber():"+stmt.getStatementNumber());
          stmt.setStatementNumber(newStatementNumber);
          System.out.println("stmt.getStatementNumber():"+stmt.getStatementNumber());
          map.put(newStatementNumber,stmt);
          System.out.println(stmt+"with number"+newStatementNumber);

      }


      System.out.println("sl1"+sl1);
      //System.out.println("sl2"+sl2);

      List<IStmt> direct_children = new ArrayList<IStmt>();
      List<IStmt> all_children = new ArrayList<IStmt>();

      System.out.println("This is sl1.getKey():"+sl1.getKey());
      List<IStmt> empty_list = new ArrayList<IStmt>();
      IfStmt if_stmt = new IfStmt((Exp)e,sl1.getKey(),sl2.getKey(),count-sl1.getValue().size()-sl2.getValue().size(),sl1.getValue().size()+sl2.getValue().size());
      //if_stmt.setNextInstruction(count+1);
      System.out.println("if_stmt.setNextInstruction is: "+(count+1));
      direct_children.add(if_stmt);
      all_children.add(if_stmt);
      all_children.addAll(sl1.getValue());
      all_children.addAll(sl2.getValue());


        System.out.println("count in if"+count);

       Pair<List<IStmt>, List<IStmt>> res = new Pair<>(direct_children, all_children);

       System.out.println("Pair<List<IStmt>, List<IStmt>> res = "+res);
       RESULT = res;
       map.put(count-sl1.getValue().size()-sl2.getValue().size(),if_stmt);
       count++;
     :}
    | error:e
    {: parser.report_error("Syntax error, skipped nonsense",e); :}
    ;


logicexpr ::= BOOLCONST:c
    {: System.out.println("BOOLCONST");
       RESULT = new ValueExp(new BoolValue(c));  :}
    | expr:e1 COMP:op expr:e2
    {: System.out.println("COMP"); RESULT = new RelationalExp(op,e1,e2); //RelationalExp
     :}

    ;
stringexp ::= STRINGCONST:sc
    {: System.out.println("STRINGCONST");
      RESULT = new ValueExp(new StringValue(sc));  :}
    ;

expr ::= INTCONST:c
    {: //System.out.println("new ValueExp(new IntValue("+c+")");
      //RESULT = "new ValueExp(new IntValue("+c+"))";
     RESULT = new ValueExp(new IntValue(c));  :}

    | IDENT: i
    {: RESULT = new VarExp(i); :}
    | LPAR expr:e RPAR
    {: RESULT = e;
     :}

    | expr:e1 BINOPPRIORITY1:op expr:e2
    {:  System.out.println("BINOP:op"+op);
    RESULT = new ArithExp(op,e1, e2);
    :}
    | expr:e1 BINOPPRIORITY2:op expr:e2
    {:  System.out.println("new ArithExp("+op+","+e1+","+ e2+")");
    RESULT = new ArithExp(op,e1, e2);
    :}
    | BINOPPRIORITY2:op expr:e
    {:  System.out.println("BINOP:op"+op);
    if(op=='+')
        RESULT = e;
    else if(op=='-')
        RESULT = new ArithExp('*',e, new ValueExp(new IntValue(-1)));
    :}
    | expr:e1 BBINOP:op expr:e2
     {: RESULT = new LogicExp(op,e1,e2); //LogicExp
      :}
    | logicexpr : l
     {:System.out.println("BOOLCONST");
       RESULT = l;
     :}
     | READ_INTEGER
     {:
      RESULT = new GetInput();
     :}
     | READ_HEAP LPAR expr:e RPAR
     {:
      RESULT = new rH(e);
     :}
     | stringexp:s
     {: //System.out.println("stringexp");
        RESULT = s;
     :}

    ;